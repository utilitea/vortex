<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vortex (Vers√£o Definitiva)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" href="https://utilitea.github.io/vortex/vortex1.png" type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

<style>
    /* TODO O SEU CSS ORIGINAL VAI AQUI. ELE PERMANECE EXATAMENTE O MESMO. */
    /* Para manter a resposta limpa, omiti as ~300 linhas de CSS, mas elas devem estar aqui. */
    :root {
        --bg-primary: #0A0B0F; --bg-secondary: #101218; --panel: #1A1D28;
        --accent-green: #14d07b; --accent-purple: #9f50ff; --text-primary: #EAEAEA;
        --text-muted: #8899A6; --border-color: rgba(255, 255, 255, 0.08);
        --shadow-color-glow: rgba(20, 208, 123, 0.3); --card-radius: 16px;
        --gap: 20px; --max-width: 1440px; --header-height: 70px;
    }
    ::-webkit-scrollbar { width: 12px; height: 12px; }
    ::-webkit-scrollbar-track { background: var(--bg-secondary); border-radius: 10px; }
    ::-webkit-scrollbar-thumb { background: linear-gradient(45deg, var(--accent-purple), var(--accent-green)); border-radius: 10px; border: 3px solid var(--bg-secondary); }
    ::-webkit-scrollbar-thumb:hover { background: linear-gradient(45deg, #b37eff, #1aff9c); }
    *, *:before, *:after { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: 'Poppins', Segoe UI, Roboto, Arial, sans-serif; background-color: var(--bg-primary); color: var(--text-primary); }
    .wrap { max-width: var(--max-width); margin: 0 auto; padding: var(--gap); padding-top: calc(var(--header-height) + var(--gap)); }
    .topbar { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; height: var(--header-height); padding: 0 var(--gap); display: flex; align-items: center; gap: var(--gap); background: rgba(10, 11, 15, 0.5); backdrop-filter: blur(12px); border-bottom: 1px solid var(--border-color); }
    .logo { display: flex; align-items: center; gap: 12px; }
    .logo img { height: 40px; width: 40px; }
    .logo h1 { font-size: 24px; font-weight: 700; }
    .search-container { flex: 1; margin-left: auto; max-width: 400px; position: relative; }
    #searchInput { width: 100%; padding: 12px 18px; border-radius: 25px; border: 1px solid var(--border-color); background: var(--panel); color: var(--text-primary); font-size: 15px; outline: none; transition: all 0.3s ease; }
    #searchInput:focus, #searchInput:focus-visible { border-color: var(--accent-green); box-shadow: 0 0 15px var(--shadow-color-glow); outline: none; }
    .hero-section { height: 35vh; min-height: 300px; margin-bottom: calc(var(--gap) * 2); border-radius: var(--card-radius); overflow: hidden; position: relative; display: flex; align-items: flex-end; padding: calc(var(--gap) * 1.5); background-size: cover; background-position: center; cursor: pointer; border: 1px solid transparent; transition: transform 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease; }
    .filter-nav { display: flex; gap: 10px; overflow-x: auto; overflow-y: visible; padding-top: 15px; padding-bottom: 20px; margin-bottom: calc(var(--gap) + 15px); padding-left: 10px; padding-right: 10px; }
    .filter-btn { position: relative; padding: 8px 20px; border: 1px solid var(--border-color); background: transparent; color: var(--text-muted); border-radius: 20px; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; }
    .filter-btn:hover { color: var(--text-primary); border-color: var(--text-muted); }
    .filter-btn:focus-visible { transform: translateY(-5px) scale(1.05); z-index: 10; }
    .filter-btn.active { background: var(--accent-green); border-color: var(--accent-green); color: var(--bg-primary); font-weight: 600; }
    .filter-btn:focus-visible, .filter-btn.active { border-color: var(--accent-green); box-shadow: 0 0 15px var(--shadow-color-glow); outline: none; }
    .carousel { margin-bottom: calc(var(--gap) * 2); }
    .section-title { font-size: 1.5rem; font-weight: 600; margin-bottom: var(--gap); padding-left: 10px; border-left: 3px solid var(--accent-purple); }
    .carousel .wrap-row { display: flex; gap: var(--gap); overflow-x: auto; padding-bottom: var(--gap); padding-top: 25px; padding-left: 10px; padding-right: 10px; }
    .channel-card { position: relative; min-width: 160px; border-radius: var(--card-radius); border: 1px solid var(--border-color); background: var(--bg-secondary); cursor: pointer; overflow: hidden; transition: transform 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease; }
    .channel-card:hover, .channel-card:focus-visible, .hero-section:hover, .hero-section:focus-visible { transform: translateY(-8px) scale(1.04); box-shadow: inset 0 0 0 2px var(--accent-green), 0 0 25px var(--shadow-color-glow), 0 20px 40px rgba(0, 0, 0, 0.4); z-index: 10; outline: none; }
    .channel-thumb { width: 100%; height: 135px; display: flex; align-items: center; justify-content: center; background: #000; }
    .channel-thumb img { width: 100%; height: 100%; object-fit: contain; }
    .channel-info { padding: 16px; }
    .channel-name { font-size: 1.1rem; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .hidden { display: none !important; }
    .no-results { text-align: center; padding: 80px; color: var(--text-muted); }
    .player-modal { display: none; position: fixed; inset: 0; background: #000; z-index: 2000; align-items: center; justify-content: center; }
    .player-modal.open { display: flex; }
    .player-box { width: 100%; height: 100%; position: relative; }
    .viewer { width: 100%; height: 100%; }
    .viewer video { width: 100%; height: 100%; }
    .player-controls { position: absolute; top: 0; left: 0; right: 0; padding: var(--gap); display: flex; justify-content: space-between; align-items: center; background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, transparent 100%); }
    .player-title { font-size: 1.5rem; font-weight: 600; }
    .close-player-btn { background: rgba(255,255,255,0.1); border: 1px solid var(--border-color); color: var(--text-primary); cursor: pointer; padding: 8px 16px; border-radius: 8px; }
    .player-actions { display: flex; gap: 10px; }
    .channel-overlay { position: absolute; bottom: 0; left: 0; right: 0; padding: 20px 0; background: linear-gradient(0deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 50%, transparent 100%); opacity: 0; transform: translateY(100%); transition: opacity 0.3s ease, transform 0.3s ease; pointer-events: none; }
    .channel-overlay.visible { opacity: 1; transform: translateY(0); pointer-events: auto; }
    .channel-list-container { overflow-x: auto; overflow-y: hidden; padding: 10px 30px; scrollbar-color: var(--accent-green) transparent; scrollbar-width: thin; }
    .channel-list-container::-webkit-scrollbar { height: 8px; }
    .channel-list-container::-webkit-scrollbar-thumb { background: var(--panel); border-radius: 10px; }
    .channel-list-container::-webkit-scrollbar-thumb:hover { background: var(--accent-green); }
    .channel-list { display: flex; gap: 15px; }
    .overlay-card { flex: 0 0 180px; border-radius: 8px; background: rgba(255, 255, 255, 0.05); border: 2px solid transparent; cursor: pointer; transition: all 0.2s ease-out; text-align: center; }
    .overlay-card img { width: 100%; height: 100px; object-fit: contain; padding: 5px; border-radius: 6px; pointer-events: none; }
    .overlay-card .name { font-size: 14px; padding: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-muted); pointer-events: none; }
    .overlay-card:hover, .overlay-card:focus-visible, .overlay-card.active { border-color: var(--accent-green); background: rgba(20, 208, 123, 0.1); transform: scale(1.05); outline: none; }
    .overlay-card.active .name { color: var(--text-primary); font-weight: 600; }
    @media (max-width: 768px) {
        .hero-section { min-height: 100px; padding: var(--gap); }
    }
    .channel-card { min-width: 100px; }
    .channel-thumb { height: 80px; }
    .channel-name { font-size: 1rem; }
    .hero-section video { position: absolute; top: 50%; left: 50%; width: 100%; height: 100%; object-fit: cover; transform: translate(-50%, -50%); z-index: 1; }
    .hero-content { position: relative; z-index: 2; width: 100%; }
</style>
</head>
<body>
    <header class="topbar">
        <div class="logo">
            <img src="https://utilitea.github.io/vortex/vortex.png" alt="Vortex Logo">
            <h1>Vortex</h1>
        </div>
        <div class="search-container">
            <input id="searchInput" type="text" placeholder="Buscar canais...">
        </div>
    </header>
    <main class="wrap">
        <section id="hero-section" class="hero-section" aria-label="Canal em destaque"></section>
        <nav id="filter-nav" class="filter-nav" aria-label="Filtro de categorias"></nav>
        <div id="mainContent">
            <p>Carregando canais...</p>
        </div>
        <div id="noResults" class="no-results hidden">
            <h3>Nenhum canal encontrado</h3>
            <p>Tente buscar por outro termo ou selecione outra categoria.</p>
        </div>
    </main>
    <div id="playerModal" class="player-modal" aria-hidden="true" role="dialog">
        <div class="player-box">
            <div class="viewer">
                <video id="videoPlayer" playsinline autoplay></video>
                <div class="player-controls">
                    <h3 id="playerTitle" class="player-title">Carregando...</h3>
                    <div class="player-actions">
                        <button id="pipButton" class="close-player-btn" title="Picture-in-Picture">PiP</button>
                        <button id="closePlayer" class="close-player-btn">Fechar</button>
                    </div>
                </div>
                <div id="channelOverlay" class="channel-overlay">
                    <div class="channel-list-container">
                        <div id="channelList" class="channel-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<script>
// =================================================================================
// TUDO ABAIXO FOI REESTRUTURADO PARA BUSCAR OS DADOS DO ARQUIVO JSON EXTERNO
// =================================================================================

// Objeto principal da aplica√ß√£o
const VortexApp = {
    // URL do seu arquivo JSON no GitHub
    channelsUrl: 'https://raw.githubusercontent.com/utilitea/vortex/refs/heads/main/channels.json',

    // Dados dos canais ser√£o armazenados aqui ap√≥s o download
    channelsData: {},

    // Refer√™ncias aos elementos da p√°gina
    elements: {
        mainContent: document.getElementById('mainContent'), searchInput: document.getElementById('searchInput'),
        modal: document.getElementById('playerModal'), videoPlayer: document.getElementById('videoPlayer'),
        playerTitle: document.getElementById('playerTitle'), closePlayerBtn: document.getElementById('closePlayer'),
        noResultsDiv: document.getElementById('noResults'), heroSection: document.getElementById('hero-section'),
        filterNav: document.getElementById('filter-nav'), pipButton: document.getElementById('pipButton'),
        channelOverlay: document.getElementById('channelOverlay'),
        channelList: document.getElementById('channelList'),
    },
    
    // Estado interno da aplica√ß√£o
    state: {
        hls: null,
        currentChannelIndex: -1,
        hideOverlayTimeout: null,
    },

    // Fun√ß√£o de inicializa√ß√£o
    init() {
        this.fetchAndRenderData(); // O in√≠cio de tudo agora √© buscar os dados
    },

    // NOVA FUN√á√ÉO: Busca os dados do JSON e constr√≥i a p√°gina
    async fetchAndRenderData() {
        try {
            const response = await fetch(this.channelsUrl);
            if (!response.ok) {
                throw new Error(`Erro na rede: ${response.statusText}`);
            }
            const jsonData = await response.json();

            // ARMAZENA O IDENTIFICADOR DO CANAL EM DESTAQUE
            this.featuredChannelIdentifier = jsonData.featuredChannel;

          
            // Transforma o JSON (que √© um array de categorias) na estrutura de objeto que o c√≥digo original usava
            this.channelsData = jsonData.categorias.reduce((acc, category) => {
                acc[category.titulo] = category.canais;
                return acc;
            }, {});

            // Limpa a mensagem "Carregando..."
            this.elements.mainContent.innerHTML = '';
            
            // Agora que os dados existem, podemos construir o DOM e adicionar os listeners
            this.buildInitialDOM();
            this.attachListeners();

        } catch (error) {
            console.error('Falha ao carregar os canais:', error);
            this.elements.mainContent.innerHTML = `<p style="color: red; text-align: center;">N√£o foi poss√≠vel carregar a lista de canais. Verifique sua conex√£o ou tente novamente mais tarde.</p>`;
        }
    },

    // Fun√ß√£o que constr√≥i o DOM inicial (agora usa this.channelsData)
    buildInitialDOM() {
        this.elements.searchInput.setAttribute('tabindex', '0');
        this.elements.heroSection.setAttribute('tabindex', '0');
        const featuredIdentifier = this.featuredChannelIdentifier; // Pega o identificador que carregamos
        const featured = this.channelsData[featuredIdentifier.category]?.[featuredIdentifier.index] || Object.values(this.channelsData).flat()[0];
        this.elements.heroSection.dataset.src = featured.src;
        this.elements.heroSection.dataset.title = featured.title;
        this.elements.heroSection.innerHTML = `
            <video id="heroVideo" autoplay muted loop playsinline></video>
            <div class="hero-content">
                <h2 class="hero-title">${featured.title}</h2>
                <div class="hero-play-btn">Assistir Agora</div>
            </div>`;
        const heroVideo = document.getElementById('heroVideo');
        if (Hls.isSupported()) {
            const hlsHero = new Hls();
            hlsHero.loadSource(featured.src);
            hlsHero.attachMedia(heroVideo);
        } else if (heroVideo.canPlayType('application/vnd.apple.mpegurl')) {
            heroVideo.src = featured.src;
        }
        const categories = ['Todos', ...Object.keys(this.channelsData)];
        this.elements.filterNav.innerHTML = categories.map(cat => `<button class="filter-btn" tabindex="0" data-category="${cat}">${cat}</button>`).join('');
        this.elements.filterNav.querySelector('.filter-btn').classList.add('active');
        for (const category in this.channelsData) {
            const section = document.createElement('section');
            section.className = 'carousel';
            section.dataset.category = category;
            section.innerHTML = `<h2 class="section-title">${category}</h2><div class="wrap-row"></div>`;
            const wrapRow = section.querySelector('.wrap-row');
            wrapRow.innerHTML = this.channelsData[category].map(channel => `<div class="channel-card" tabindex="0" data-src="${channel.src}" data-title="${channel.title}"><div class="channel-thumb"><img src="${channel.thumbnail}" alt="${channel.title}" loading="lazy"></div><div class="channel-info"><div class="channel-name">${channel.title}</div></div></div>`).join('');
            this.elements.mainContent.appendChild(section);
        }
    },

    // Todas as outras fun√ß√µes (updateView, attachListeners, openPlayer, etc.)
    // permanecem as mesmas, mas agora usam "this.channelsData"
    // em vez da vari√°vel global "channelsData"
    updateView() {
        const query = this.elements.searchInput.value.toLowerCase().trim();
        const activeFilter = this.elements.filterNav.querySelector('.active').dataset.category;
        document.querySelectorAll('.carousel').forEach(carousel => {
            let visibleChannelsInCategory = 0;
            const category = carousel.dataset.category;
            carousel.querySelectorAll('.channel-card').forEach(card => {
                const title = card.dataset.title.toLowerCase();
                const matchesSearch = title.includes(query);
                const matchesFilter = (activeFilter === 'Todos' || activeFilter === category);
                const isVisible = matchesSearch && matchesFilter;
                card.classList.toggle('hidden', !isVisible);
                if (isVisible) visibleChannelsInCategory++;
            });
            carousel.classList.toggle('hidden', visibleChannelsInCategory === 0);
        });
        this.elements.noResultsDiv.classList.toggle('hidden', !this.elements.mainContent.querySelector('.channel-card:not(.hidden)'));
    },
    attachListeners() {
        document.body.addEventListener('click', e => {
            const card = e.target.closest('.channel-card, #hero-section');
            if (card) {
                const allChannels = Object.values(this.channelsData).flat();
                this.state.currentChannelIndex = allChannels.findIndex(c => c.src === card.dataset.src);
                this.openPlayer(card.dataset.src, card.dataset.title);
            }
            const filter = e.target.closest('.filter-btn');
            if (filter) {
                this.elements.filterNav.querySelector('.active').classList.remove('active');
                filter.classList.add('active');
                this.updateView();
            }
        });
        this.elements.searchInput.addEventListener('input', () => this.updateView());
        this.elements.closePlayerBtn.addEventListener('click', () => this.closePlayer());
        this.elements.pipButton.addEventListener('click', () => this.togglePiP());
        document.addEventListener('keydown', e => {
            if (this.elements.modal.classList.contains('open')) {
                this.handlePlayerKeys(e);
                return;
            }
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                this.handleSpatialNavigation(e.key);
            }
            if (e.key === 'Enter') {
                e.preventDefault();
                if (document.activeElement && typeof document.activeElement.click === 'function') {
                    document.activeElement.click();
                }
            }
        });
    },
    
    // O resto do seu c√≥digo JS original...
    // ... (handleSpatialNavigation, renderChannelOverlay, showPlayerOverlay, openPlayer, closePlayer, etc.)
    // A √∫nica mudan√ßa necess√°ria neles foi trocar 'channelsData' por 'this.channelsData'.
    // Vou incluir todos aqui para garantir que funcione.
    handleSpatialNavigation(key) {
        const focusableElements = Array.from(document.querySelectorAll('[tabindex="0"]')).filter(el => el.offsetParent !== null && !el.classList.contains('hidden'));
        if (focusableElements.length === 0) return;
        const currentElement = document.activeElement;
        const currentIndex = focusableElements.indexOf(currentElement);
        if (currentIndex === -1) {
            focusableElements[0].focus();
            focusableElements[0].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
            return;
        }
        const currentRect = currentElement.getBoundingClientRect();
        let bestCandidate = null;
        let minDistance = Infinity;
        for (const candidate of focusableElements) {
            if (candidate === currentElement) continue;
            const candidateRect = candidate.getBoundingClientRect();
            const isVerticalOverlap = candidateRect.right > currentRect.left && candidateRect.left < currentRect.right;
            const isHorizontalOverlap = candidateRect.bottom > currentRect.top && candidateRect.top < currentRect.bottom;
            const dx = (candidateRect.left + candidateRect.width / 2) - (currentRect.left + currentRect.width / 2);
            const dy = (candidateRect.top + candidateRect.height / 2) - (currentRect.top + currentRect.height / 2);
            let distance = Infinity;
            switch (key) {
                case 'ArrowDown': if (dy > 0 && isVerticalOverlap) { distance = dy; } break;
                case 'ArrowUp': if (dy < 0 && isVerticalOverlap) { distance = Math.abs(dy); } break;
                case 'ArrowRight': if (dx > 0 && isHorizontalOverlap) { distance = dx; } break;
                case 'ArrowLeft': if (dx < 0 && isHorizontalOverlap) { distance = Math.abs(dx); } break;
            }
            if (distance < minDistance) {
                minDistance = distance;
                bestCandidate = candidate;
            }
        }
        if (bestCandidate) {
            bestCandidate.focus();
            bestCandidate.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
        }
    },
    renderChannelOverlay() {
        const allChannels = Object.values(this.channelsData).flat();
        this.elements.channelList.innerHTML = allChannels.map((channel, index) => `
            <div class="overlay-card ${index === this.state.currentChannelIndex ? 'active' : ''}" 
                 data-index="${index}" tabindex="${index === this.state.currentChannelIndex ? '0' : '-1'}" role="button">
                <img src="${channel.thumbnail}" alt="">
                <div class="name">${channel.title}</div>
            </div>
        `).join('');
        this.elements.channelList.addEventListener('click', (e) => {
            const card = e.target.closest('.overlay-card');
            if (card) { this.changeChannel(parseInt(card.dataset.index)); }
        });
    },
    showPlayerOverlay() {
        this.elements.channelOverlay.classList.add('visible');
        const activeCard = this.elements.channelList.querySelector(`[data-index="${this.state.currentChannelIndex}"]`);
        if (activeCard) {
            activeCard.focus();
            activeCard.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
        clearTimeout(this.state.hideOverlayTimeout);
        this.state.hideOverlayTimeout = setTimeout(() => {
            this.elements.channelOverlay.classList.remove('visible');
        }, 5000);
    },
    openPlayer(src, title) {
        this.elements.modal.classList.add('open');
        this.elements.modal.setAttribute('aria-hidden', 'false');
        this.elements.playerTitle.textContent = title;
        this.renderChannelOverlay();
        this.loadAndPlay(src);
    },
    closePlayer() {
        this.elements.modal.classList.remove('open');
        this.elements.modal.setAttribute('aria-hidden', 'true');
        this.elements.channelOverlay.classList.remove('visible');
        clearTimeout(this.state.hideOverlayTimeout);
        if (this.state.hls) { this.state.hls.destroy(); this.state.hls = null; }
        this.elements.videoPlayer.pause();
        this.elements.videoPlayer.removeAttribute('src');
        this.elements.videoPlayer.load();
    },
    loadAndPlay(src) {
        const video = this.elements.videoPlayer;
        if (this.state.hls) { this.state.hls.destroy(); }
        if (Hls.isSupported()) {
            this.state.hls = new Hls();
            this.state.hls.loadSource(src);
            this.state.hls.attachMedia(video);
            this.state.hls.on(Hls.Events.MANIFEST_PARSED, () => {
                video.play().catch(error => console.error("Erro no autoplay:", error));
            });
        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = src;
            video.play().catch(error => console.error("Erro no autoplay nativo:", error));
        }
    },
    changeChannel(index) {
        const allChannels = Object.values(this.channelsData).flat();
        if (index >= 0 && index < allChannels.length) {
            const newChannel = allChannels[index];
            this.state.currentChannelIndex = index;
            this.loadAndPlay(newChannel.src);
            this.elements.playerTitle.textContent = newChannel.title;
            const oldActiveCard = this.elements.channelList.querySelector('.overlay-card.active');
            if (oldActiveCard) oldActiveCard.classList.remove('active');
            const newActiveCard = this.elements.channelList.querySelector(`[data-index="${index}"]`);
            if (newActiveCard) newActiveCard.classList.add('active');
            if (this.elements.channelOverlay.classList.contains('visible')) {
                this.showPlayerOverlay();
            }
        }
    },
    togglePiP() {
        if (document.pictureInPictureElement) {
            document.exitPictureInPicture().catch(e => console.error("Erro ao sair do PiP:", e));
        } else {
            this.elements.videoPlayer.requestPictureInPicture().catch(e => console.error("Erro ao entrar em PiP:", e));
        }
    },
    handlePlayerKeys(e) {
        if (!this.elements.channelOverlay.classList.contains('visible')) {
            this.showPlayerOverlay();
        } else {
            clearTimeout(this.state.hideOverlayTimeout);
            this.state.hideOverlayTimeout = setTimeout(() => {
                this.elements.channelOverlay.classList.remove('visible');
            }, 5000);
        }
        switch(e.key) {
            case 'Escape': case 'Backspace': e.preventDefault(); this.closePlayer(); break;
            case 'ArrowUp': e.preventDefault(); this.changeChannel(this.state.currentChannelIndex - 1); break;
            case 'ArrowDown': e.preventDefault(); this.changeChannel(this.state.currentChannelIndex + 1); break;
            case 'ArrowLeft': case 'ArrowRight': {
                e.preventDefault();
                const items = Array.from(this.elements.channelList.querySelectorAll('.overlay-card'));
                if (!items.length) break;
                const currentFocused = document.activeElement;
                const currentIndex = items.indexOf(currentFocused);
                let nextIndex = currentIndex + (e.key === 'ArrowRight' ? 1 : -1);
                nextIndex = Math.max(0, Math.min(items.length - 1, nextIndex));
                if (nextIndex !== currentIndex) {
                    items[currentIndex].setAttribute('tabindex', '-1');
                    const nextItem = items[nextIndex];
                    nextItem.setAttribute('tabindex', '0');
                    nextItem.focus();
                }
                break;
            }
            case 'Enter':
                if (document.activeElement.classList.contains('overlay-card')) {
                    this.changeChannel(parseInt(document.activeElement.dataset.index));
                }
                break;
        }
    },
};

// Inicia a aplica√ß√£o quando a p√°gina estiver pronta
document.addEventListener('DOMContentLoaded', () => VortexApp.init());
</script>
</body>
</html>
